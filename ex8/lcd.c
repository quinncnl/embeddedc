/**********************************************************************************/
/*                                                                                */
/*    File   Name    :  lcd.c                                                     */
/*    Date           :  2012/02/01 initial version                                */
/*                                                                                */
/**********************************************************************************/
#include <msp430fg4619.h>
#include "lcd.h"
#include "system.h"
#include "font_full.h"


/* The LCD backlight pin is connected to P7.6 pin of the MSP430 in the Olimex board */
#define LCD_BACKLIGHT_LOW     	        P7OUT &= ~BIT6
#define LCD_BACKLIGHT_HIGH    	        P7OUT |= BIT6

/* The LCD reset pin is connected to P7.4 pin of the MSP430 in the Olimex board */
#define LCD_RESET_LOW     	        P7OUT &= ~BIT4
#define LCD_RESET_HIGH    	        P7OUT |= BIT4

/* The LCD CS pin for the SPI interface is connected to P4.2 pin in the Olimex board */
#define LCD_SPI_CS_LOW    		P4OUT &= ~BIT2;	
#define LCD_SPI_CS_HIGH   		P4OUT |= BIT2;	

/* The LCD UCLK and SIMO pins for the SPI interface are connected 
   to P4.5 and P4.3 (respectively) pin in the Olimex board */
#define LCD_SPI_UCLK_LOW    		P4OUT &= ~BIT5;	
#define LCD_SPI_UCLK_HIGH   		P4OUT |= BIT5;	
#define LCD_SPI_SIMO_LOW    		P4OUT &= ~BIT3;	
#define LCD_SPI_SIMO_HIGH   		P4OUT |= BIT3;	


// Global variables to keep track of RGB data sent,
// in order to pack 2 12-bit RGB colors into 3 bytes sent over the SPI channel
static unsigned char lcd_pack_rgb_state = 0;
static unsigned char lcd_pack_rgb_value;


/****************************************************************************/
/*  Function : LCD_InitSPI                                                  */
/*     Initializes the SPI channel to communicate with the LCD controller   */
/*     Assumes SMCLK freq is 8MHz                                           */
/****************************************************************************/
void LCD_InitSPI (void) {

  /* The Olimex board connects the LCD controller with the MSP430 microcontroller
     using the USART1 communications channel in SPI mode.
	 
     The problem is the LCD controller expects a 9-bit SPI interface while
     USART1 in SPI mode is 7-bits/8-bits only, so in each transfer the SPI signals 
     for one of the 9 bits to be transferred will have to be generated by software,
     the other 8 bits can be transferred automatically with the USART1 module.
	 
     Fortunately the first bit to be transmitted to the LCD controller is 
     *not* part of value but A0 (address bit 0 in the parallel interface), a bit
     which determines if the information sent is a command or a data value.
     So in this implementation it will be A0 the bit to be transferred by software,
     using different functions (command / data) in order to transfer A0 = 0 / 1 first.
  */

  /* From the TI MSP430X4XX Family User Guide:
  
      Note: Initializing or Reconfiguring the USART Module
      The required USART initialization/reconfiguration process is:
  
      1) Set SWRST (BIS.B #SWRST,&UxCTL)
      2) Initialize all USART registers with SWRST=1 (including UxCTL)
      3) Enable USART module via the MEx SFRs (USPIEx)
      4) Clear SWRST via software (BIC.B #SWRST,&UxCTL)
      5) Enable interrupts (optional) via the IEx SFRs (URXIEx and/or UTXIEx)
  
      Failure to follow this process may result in unpredictable USART behavior.
  */

  // USART1 Control Register (UCTL1 is the alternate name for U1CTL)
  // XX         - Unused bits
  // I2C = 0    - SPI mode ON (this bit is NOT implemented in 4xx devices)
  // CHAR = 1   - 8-bit data mode ON (7-bit data mode OFF)
  // LISTEN = 0 - Loopback mode OFF
  // SYNC = 0   - SPI mode ON (UART mode OFF)
  // MM = 1     - USART is MASTER
  // SWRST = 1  - Software reset
  
  // First force the software reset if the USART
  UCTL1 = SWRST;
  // Then programa the mode to 8-bit, SPI Master (maintaining the software reset)
  UCTL1 = CHAR + SYNC + MM + SWRST;	

  // USART Transmit Control Register:
  // CKPH = 0 - Data changed on the first edge, captured on the following
  // CKPL = 1 - Inactive state is HIGH
  // SSELx = 11 - Use SMCLK clock source select
  // XX         - Unused bits
  // STC = 1    - 3-pin SPI mode ON (STE disabled)
  // TXEPT is read only - Transmission active or data waiting in U1TXBUF when 0,
  //                      U1TXBUF and TX shift register is empty when 1
  // Select SMCLK and 3-pin SPI, Clock Polarity (sample data on the clock rising edge)
  U1TCTL = SSEL0 + SSEL1 + STC + CKPL;	

  // USART Baud Rate Control Registers 0 and 1
  // From the TI MSP430X4XX Family User Guide:
  // The baudrate is BRCLK / U1BR, with 
  //    BRCLK: the USART selected clock (from UCLK, ACLK or SMCLK)
  //    U1BR: {U1BR1 << 8 + U1BR0} (UBR01 and UBR11 are the alternate names
  //                                  for U1BR0 and U1BR1 respectively)
  // so if U1BR = 4 and assuming SMCLK = 8 MHz ...
  //    baudrate is SMCLK / 4 = 8MHz / 4 = 2 MHz
  UBR01   = 0x04;	
  UBR11   = 0x00;
        
  // USART Modulation Control Register:
  // Is not used for SPI and should be set to zero
  UMCTL1  = 0x00;
  
  // Enable USART1 in SPI mode (U1ME is the alternate name for ME2)
  U1ME |= USPIE1;

  // USART reset released for operation
  UCTL1 &= ~SWRST;

  // Setup P4 for USART1 operation
  P4SEL |= BIT3 + BIT5;		// Claim P4.3 and P4.5 for SPI (not GPIO)

  P4SEL &= ~BIT2;		// Set P4.2 as GPIO (CS of the LCD SPI interface)
  // P4OUT |= BIT2;		// CS high
  LCD_SPI_CS_HIGH;		// CS high	
  P4DIR |= BIT2;		// P4.2 output direction

  //	Reset Pin
  P7SEL &= ~BIT4;		// Set P7.4 as GPIO (Reset of the LCD)
  //P7OUT |= BIT4;		// reset high
  LCD_RESET_HIGH;		// reset high
  P7DIR |= BIT4;		// P7.4 output direction

  // Backlight
  P7SEL &= ~BIT6;               // Set P7.6 as GPIO (Backlight of the LCD)
  // P7OUT &= ~BIT6;     // Turn on light
  LCD_BACKLIGHT_LOW;            // Backlight LOW to turn on backlight (signal is active LOW)
  P7DIR |= BIT6;                // P7.6 output direction
}


/****************************************************************************/
/*  Function : LCD_Settings                                                 */
/*     Startup settings for the GE8/GE12 LCD controller                     */
/*     Set the RGB packing mode ON/OFF                                      */
/****************************************************************************/
void LCD_Settings (void) {

#ifdef LCD_GE12_ONBOARD
  LCD_GE12_Settings ();
#else // LCD_GE12_ONBOARD
  LCD_GE8_Settings ();
#endif // LCD_GE12_ONBOARD
}


/****************************************************************************/
/*  Function : LCD_WriteSPICommand                                          */
/*     Write a 8-bits command to the LCD controller                         */
/*  Parameters :                                                            */
/*     data8 - comand value                                                 */
/****************************************************************************/
void LCD_WriteSPICommand (unsigned char data8) {

  /* Software generated SPI signals for the first bit (A0 = 0 for a command) */

  /* Temporarily set P4.3 and P4.5 as GPIO to set
       P4.5 HIGH and P4.3 LOW, then CS LOW, then P4.5 LOW, then P4.5 HIGH.
	   (1)                          (2)           (3)           (4)
    This sequence creates the following waveform on the SPI interface:
	 
                       (1)   (2)   (3)   (4)
		       <-----------(A0 = 0)------->
                    ..._____________      _________
   P4.5 (SPI clock) ...            |______|
                                          ^
					  |
					  +-- Sample time of SPI data (bit value = 0)
                    ...
   P4.3 (SPI data)  ...____________________________
   
                    .........
   P4.2 (SPI CS)    .........______________________
  */

  P4SEL &= ~(BIT3 + BIT5);    // Temporarily set P4.3 and P4.5 as GPIO
  LCD_SPI_UCLK_HIGH;          // Set P4.5 pin HIGH
  LCD_SPI_SIMO_LOW;           // Set P4.3 pin LOW
  P4DIR |= BIT3 + BIT5;       // Set direction of P4.3 and P4.5 as OUTPUTs        
        
  /* Software generated SPI signal CS LOW */
  LCD_SPI_CS_LOW;

  /* Toggle SPI clock (first LOW then HIGH) */
  LCD_SPI_UCLK_LOW;           // Set P4.5 pin LOW
  LCD_SPI_UCLK_HIGH;          // Set P4.5 pin HIGH

  /* Now that the first bit has been sent to the LCD controller 
     the other 8 bits can be sent using the USART1 (already configured in SPI mode) */

  P4SEL |= BIT3 + BIT5;	      // Claim back P4.3 and P4.5 for SPI (not GPIO)

  /* Send data (the write to the transmit buffer automatically starts the transmission) */
  TXBUF1 = data8;

  /* Wait for the transmit buffer to be empty before sending more data */
  while ((U1TCTL & TXEPT) == 0);	

  // CS High
  LCD_SPI_CS_HIGH;
}


/****************************************************************************/
/*  Function : LCD_WriteSPIData                                             */
/*     Write a 8-bits data value to the LCD controller                      */
/*  Parameters :                                                            */
/*     data8 - data value                                                   */
/****************************************************************************/
void LCD_WriteSPIData (unsigned char data8) {

  /* Software generated SPI signals for the first bit (A0 = 1 for data) */

  /* Temporarily set P4.3 and P4.5 as GPIO to set
       P4.5 HIGH and P4.3 HIGH, then CS LOW, then P4.5 LOW, then P4.5 HIGH.
	   (1)                          (2)           (3)           (4)
	   This sequence creates the following waveform on the SPI interface:
	 
                       (1)   (2)   (3)   (4)
		       <-----------(A0 = 1)------->
                    ..._____________      _________
   P4.5 (SPI clock) ...            |______|
                                          ^
					  |
					  +-- Sample time of SPI data (bit value = 1)
                    ...____________________________
   P4.3 (SPI data)  ...
   
                    .........
   P4.2 (SPI CS)    .........______________________
  */
  P4SEL &= ~(BIT3 + BIT5);	// Temporarily set P4.3 and P4.5 as GPIO
  LCD_SPI_UCLK_HIGH;
  LCD_SPI_SIMO_HIGH;
  P4DIR |= BIT3 + BIT5;  	// Set direction of P4.3 and P4.5 as OUTPUTs

  /* Software generated SPI signal CS LOW */
  LCD_SPI_CS_LOW;

  /* Toggle SPI clock (first LOW then HIGH) */
  LCD_SPI_UCLK_LOW;             // Set P4.5 pin LOW
  LCD_SPI_UCLK_HIGH;            // Set P4.5 pin HIGH

	
  /* Now that the first bit has been sent to the LCD controller 
     the other 8 bits can be sent using the USART1 (already configured in SPI mode) */

  P4SEL |= BIT3 + BIT5;		// Claim back P4.3 and P4.5 for SPI (not GPIO)

  /* Send data (the write to the transmit buffer automatically starts the transmission) */
  TXBUF1 = data8;

  /* Wait for the transmit buffer to be empty before sending more data */
  while ((U1TCTL & TXEPT) == 0);

  // CS High
  LCD_SPI_CS_HIGH;
}


/****************************************************************************/
/*  Function : WriteSPIRBGData                                              */
/*     Write a 12-bits RGB data value to the LCD controller                 */
/*     supports packed and unpacked RBG values                              */
/*  Parameters :                                                            */
/*     data12 - RGB data value                                              */
/****************************************************************************/
void LCD_WriteSPIRGBData (unsigned int data12) {
  unsigned char data;
  
  if (lcd_pack_rgb_state) {
    // Even RGB data.
    // Pack its R component with the stored B component of the previous (odd) RGB data.
    // Send the packed data and then the GB components
    lcd_pack_rgb_state = 0;
    // Pack the Blue part from the previous RGB value
    // with the Red part from this one to send it.
    lcd_pack_rgb_value = lcd_pack_rgb_value | ((data12 >> 8) & 0x000F);
    LCD_WriteSPIData (lcd_pack_rgb_value);
    // Then send the Green and Blue parts of this RGB value.
    // Calculate the 8-bit data to sent now (the Green and Blue parts as 0xGB)
    data = data12 & 0x00FF;
    LCD_WriteSPIData (data);
  } else {
    // Odd RGB data. 
    // Send RG now, store B to be sent packed with the following (even) RGB data
    lcd_pack_rgb_state = 1;
    // Store the Blue part for the next transmission as 0x00B0
    lcd_pack_rgb_value = (data12 & 0x000F) << 4;
    // Calculate the 8-bit data to sent now (the Red and Green parts as 0xRG)
    data = (data12 >> 4) & 0x00FF;
    LCD_WriteSPIData (data);
  }
}


/****************************************************************************/
/*  Function : LCD_Backlight                                                */
/*     Turn on/off the backlght of the LCD                                  */
/*  Parameters :                                                            */
/*     state - LCD_BACKLIGHT_ON to turn the light on,                       */
/*             LCD_BACKLIGHT_OFF to turn it off                             */
/****************************************************************************/
void LCD_Backlight (unsigned char on_off) {
  if (on_off == LCD_BACKLIGHT_ON)
      LCD_BACKLIGHT_HIGH;           // Turn on (P7.6 = 1)
  else
      LCD_BACKLIGHT_LOW;            // Turn off (P7.6 = 0)
}


/****************************************************************************/
/*  Function : LCD_SetDrawingArea                                           */
/*     Prepare the drawing area on the LCD screen                           */
/*  Parameters :                                                            */
/*     start_x - Initial page (row). Range [0, 131]                         */
/*     end_x   - Final page (row). Range [0, 131]                           */
/*     start_y - Initial column. Range [0, 131]                             */
/*     end_y   - Final column. Range [0, 131]                               */
/****************************************************************************/
void LCD_SetDrawingArea (unsigned int start_x, unsigned int end_x, 
			unsigned int start_y, unsigned int end_y) {

  // Set start and end page
  LCD_WriteSPICommand (LCD_COMMAND_PAGEADDRSET);
  LCD_WriteSPIData (start_x);
  LCD_WriteSPIData (end_x);

  // Set start and end column
  LCD_WriteSPICommand (LCD_COMMAND_COLUMNADDRSET);
  LCD_WriteSPIData (start_y);
  LCD_WriteSPIData (end_y);
}


/****************************************************************************/
/*  Function : LCD_FillArea                                                 */
/*     Prepare the drawing area on the LCD screen                           */
/*  Parameters :                                                            */
/*     start_x - Initial page (row). Range [0, 131]                         */
/*     end_x   - Final page (row). Range [0, 131]                           */
/*     start_y - Initial column. Range [0, 131]                             */
/*     end_y   - Final column. Range [0, 131]                               */
/*     color   - RGB color 12-bit (0000RRRRGGGGBBBB)                        */
/****************************************************************************/
void LCD_FillArea (unsigned int start_x, unsigned int end_x, 
			unsigned int start_y, unsigned int end_y,
                        unsigned int color) {
  int page, column;
  int no_bytes = (end_x - start_x + 1) * (end_y - start_y + 1);

  // Prepare the area to be filled
  LCD_SetDrawingArea (start_x, end_x, start_y, end_y);
	
  // Send the MEMORY-WRITE command to send RGB pixel values
  LCD_WriteSPICommand (LCD_COMMAND_MEMWRITE);

  // Write RGB values to the LCD memory
  for(page = start_x; page <= end_x; page++) {
    for(column = start_y; column <= end_y; column++) {
      LCD_WriteSPIRGBData (color);
    }
  }

  // If the no of pixels of the area is odd one more data is required 
  // in order to send the last part of the last pixel.
  // The added data is irrelevant, 
  // it gets out from the drawing area and the LCD automatically discards it
  if ( no_bytes % 2 ) {
    LCD_WriteSPIRGBData (0);
    // Send any command to ensure the extra RGB data is discarded, just in case
    LCD_WriteSPICommand (LCD_COMMAND_NOP);
  }
          
  // Send the LCD DISPLAY-ON command
  LCD_WriteSPICommand (LCD_COMMAND_DISPLAY_ON);
}


/****************************************************************************/
/*  Function : LCD_Clear                                                    */
/*     Clear the LCD screen writing R = 0xF, G = 0xF, B = 0xF               */
/*     on all pixels                                                        */
/****************************************************************************/
void LCD_Clear (void) {
  LCD_FillArea (0, 131, 0, 131, LCD_COLOR_WHITE);
}


/****************************************************************************/
/*  Function : LCD_DrawHorLine                                              */
/*     Draw a vertical line on the LCD screen                               */
/*  Parameters :                                                            */
/*     start_x - Initial page (row). Range [0, 131]                         */
/*     end_x   - Final page (row). Range [0, 131]                           */
/*     y       - Column. Range [0, 131]                                     */
/*     color   - RGB color 12-bit (0000RRRRGGGGBBBB)                        */
/****************************************************************************/
void LCD_DrawHorLine (unsigned int start_x, unsigned int end_x, 
                       unsigned int y, unsigned int color) {
  int page;
  int no_bytes = (end_x - start_x + 1);

  // Prepare the area to be filled
  LCD_SetDrawingArea (start_x, end_x, y, y);
	
  // Send the MEMORY-WRITE command to send RGB pixel values
  LCD_WriteSPICommand (LCD_COMMAND_MEMWRITE);

  // Write RGB values to the LCD memory
  for(page = start_x; page <= end_x; page++) {
    LCD_WriteSPIRGBData (color);
  }

  // If the no of pixels of the area is odd one more data is required 
  // in order to send the last part of the last pixel.
  // The added data is irrelevant, 
  // it gets out from the drawing area and the LCD automatically discards it
  if ( no_bytes % 2 ) {
    LCD_WriteSPIRGBData (0);
    // Send any command to ensure the extra RGB data is discarded, just in case
    LCD_WriteSPICommand (LCD_COMMAND_NOP);
  }
          
  // Send the LCD DISPLAY-ON command
  LCD_WriteSPICommand (LCD_COMMAND_DISPLAY_ON);                       
}


/****************************************************************************/
/*  Function : LCD_DrawVertLine                                             */
/*     Draw an horizontal line on the LCD screen                            */
/*  Parameters :                                                            */
/*     start_y - Initial column. Range [0, 131]                             */
/*     end_y   - Final column. Range [0, 131]                               */
/*     x       - Page (row). Range [0, 131]                                 */
/*     color   - RGB color 12-bit (0000RRRRGGGGBBBB)                        */
/****************************************************************************/
void LCD_DrawVertLine (unsigned int start_y, unsigned int end_y, 
			unsigned int x, unsigned int color) {                       
  int column;
  int no_bytes = (end_y - start_y + 1);

  // Prepare the area to be filled
  LCD_SetDrawingArea (x, x, start_y, end_y);
	
  // Send the MEMORY-WRITE command to send RGB pixel values
  LCD_WriteSPICommand (LCD_COMMAND_MEMWRITE);

  // Write RGB values to the LCD memory
  for(column = start_y; column <= end_y; column++) {
    LCD_WriteSPIRGBData (color);
  }

  // If the no of pixels of the area is odd one more data is required 
  // in order to send the last part of the last pixel.
  // The added data is irrelevant, 
  // it gets out from the drawing area and the LCD automatically discards it
  if ( no_bytes % 2 ) {
    LCD_WriteSPIRGBData (0);
    // Send any command to ensure the extra RGB data is discarded, just in case
    LCD_WriteSPICommand (LCD_COMMAND_NOP);
  }
          
  // Send the LCD DISPLAY-ON command
  LCD_WriteSPICommand (LCD_COMMAND_DISPLAY_ON);                       
}


/****************************************************************************/
/*  Function : LCD_DrawRectangle                                            */
/*     Draw a rectangle on the LCD screen                                   */
/*  Parameters :                                                            */
/*     start_x - Initial page (row). Range [0, 131]                         */
/*     end_x   - Final page (row). Range [0, 131]                           */
/*     start_y - Initial column. Range [0, 131]                             */
/*     end_y   - Final column. Range [0, 131]                               */
/*     color   - RGB color 12-bit (0000RRRRGGGGBBBB)                        */
/****************************************************************************/
void LCD_DrawRectangle (unsigned int start_x, unsigned int end_x, 
			unsigned int start_y, unsigned int end_y,
                        unsigned int color) {
  LCD_DrawVertLine (start_y, end_y, start_x, color);
  LCD_DrawVertLine (start_y, end_y, end_x, color);
  LCD_DrawHorLine  (start_x, end_x, end_y, color);
  LCD_DrawHorLine  (start_x, end_x, start_y, color);
}


/****************************************************************************/
/*  Function : LCD_DrawFilledRectangle                                      */
/*     Draw a rectangle on the LCD screen and fill it with a (possible)     */
/*     different color                                                      */
/*  Parameters :                                                            */
/*     start_x    - Initial page (row). Range [0, 131]                      */
/*     end_x      - Final page (row). Range [0, 131]                        */
/*     start_y    - Initial column. Range [0, 131]                          */
/*     end_y      - Final column. Range [0, 131]                            */
/*     line_color - line color, RGB color 12-bit (0000RRRRGGGGBBBB)         */
/*     fill_color - fill color, RGB color 12-bit (0000RRRRGGGGBBBB)         */
/****************************************************************************/
void LCD_DrawFilledRectangle (unsigned int start_x, unsigned int end_x, 
			unsigned int start_y, unsigned int end_y,
                        unsigned int line_color, unsigned int fill_color) {
  // First draw the rectangle
  LCD_DrawRectangle (start_x, end_x, start_y, end_y, line_color);
  // If it is not really a rectangle but a (horizontal/vertical) line, 
  // there is nothing to fill
  if ((end_x == start_x) || (end_y == start_y))
    return;
  // If the rectangle is so thin there is no space for a line inside, 
  // there is nothing to fill neither
  if ((end_x == start_x + 1) || (end_y == start_y + 1))
    return;
  // In the general case, there is something to fill
  if ((end_x > (start_x + 1)) && (end_y > (start_y + 1)))
    LCD_FillArea (start_x + 1, end_x - 1, start_y + 1, end_y - 1, fill_color);
}


void LCD_WriteChar (unsigned char Ascii, 
                  unsigned char x,
                  unsigned char y,
                  unsigned short FG_Colour, unsigned short BG_Colour) 
{
    unsigned int i, j;

    unsigned char Byte_1 = 0;
    unsigned char Byte_2 = 0;
    unsigned char Byte_3 = 0;
    unsigned char Pixel = 0;

    LCD_WriteSPICommand (CASET);
    LCD_WriteSPIData (y); // (LCD_X_OFFSET + x);
    LCD_WriteSPIData (y + FONT_WIDTH - 1); //(LCD_X_OFFSET + x + FONT_WIDTH - 1);

    LCD_WriteSPICommand (PASET);
    LCD_WriteSPIData (x); //(LCD_Y_OFFSET + y);
    LCD_WriteSPIData (x + FONT_HEIGHT - 1); //(LCD_Y_OFFSET + y + FONT_HEIGHT - 1);

    LCD_WriteSPICommand (RAMWR);

    for (j = 0; j < FONT_HEIGHT; j++) 
    {
        Pixel = font_digits[j + (FONT_HEIGHT * Ascii)];
        for (i = 0; i < FONT_WIDTH; i++)
        {
            if (i % 2)
            {
                if (Pixel & 0x80)      // Pixel ON
                {
                    Byte_2 &= 0xF0;
                    Byte_2 |= FG_Colour >> 8;
                    Byte_3 = FG_Colour & 0x00FF;
                }
                else                  // Pixel OFF
                {
                    Byte_2 &= 0xF0;
                    Byte_2 |= BG_Colour >> 8;
                    Byte_3 = BG_Colour & 0x00FF;
                }
                LCD_WriteSPIData (Byte_1);
                LCD_WriteSPIData (Byte_2);
                LCD_WriteSPIData (Byte_3);
            }
            else
            {
                if (Pixel & 0x80)      // Pixel ON
                {
                    Byte_1 = FG_Colour >> 4;
                    Byte_2 = FG_Colour << 4;
                }
                else                // Pixel OFF
                {
                    Byte_1 = BG_Colour >> 4;
                    Byte_2 = 0;
                    Byte_2 |= BG_Colour << 4;
                }
            }
            Pixel <<= 1;
        }
    }
}


/*
void ClearBall(unsigned char row, unsigned char col) {

#ifdef GE12

  // Page address set
  LCD_WriteSPICommand(PAGEADDRSET);
  LCD_WriteSPIData(row);
  LCD_WriteSPIData(row+19);

  // Column address set
  LCD_WriteSPICommand(COLADDRSET);
  LCD_WriteSPIData(col);
  LCD_WriteSPIData(col+19);

  // WRITE MEMORY
  LCD_WriteSPICommand(MEMWRITE);

  for(j=0; j<600; j++) {
    LCD_WriteSPIData(0xff);
  }

  // Display On

  LCD_WriteSPICommand(DISPLAYON);

#else

  // Page address set
  LCD_WriteSPICommand(PASET);
  LCD_WriteSPIData(row);
  LCD_WriteSPIData(row+19);

  // Column address set
  LCD_WriteSPICommand(CASET);
  LCD_WriteSPIData(col);
  LCD_WriteSPIData(col+19);

  // WRITE MEMORY
  LCD_WriteSPICommand(RAMWR);

  for(j=0; j<600; j++) {
    LCD_WriteSPIData(0xff);
  }

  // Display On

  LCD_WriteSPICommand(DISON);

#endif

}

void WriteBall(unsigned char row, unsigned char col) {

#ifdef GE12

  // Page address set
  LCD_WriteSPICommand(PAGEADDRSET);
  LCD_WriteSPIData(row);
  LCD_WriteSPIData(row+19);

  // Column address set
  LCD_WriteSPICommand(COLADDRSET);
  LCD_WriteSPIData(col);
  LCD_WriteSPIData(col+19);

  // WRITE MEMORY
  LCD_WriteSPICommand(MEMWRITE);

  for(j=0; j<600; j++) {
    LCD_WriteSPIData(ball[j]);
  }

  // Display On
  //LCD_WriteSPICommand(DISPLAYON);

#else

  // Page address set
  LCD_WriteSPICommand(PASET);
  LCD_WriteSPIData(row);
  LCD_WriteSPIData(row+19);

  // Column address set
  LCD_WriteSPICommand(CASET);
  LCD_WriteSPIData(col);
  LCD_WriteSPIData(col+19);

  // WRITE MEMORY
  LCD_WriteSPICommand(RAMWR);

  // @FRB-
  //for(j=0; j<600; j++) {
  // @FRB+
  for(j=0; j<BALL_SIZE; j++) {
    // @FRB-
    //LCD_WriteSPIData(ball[j]);
    // @FRB+
    LCD_WriteSPIData(ball[j%BALL_ACTUAL_SIZE]);
  }

#endif

}
*/
